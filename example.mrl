tensor_t: itype = {
    shape: readonly int[],
    ndims: constant int
}

vector_t: itype tensor_t = {
    ndims: iconstant int = 1,
    length: int,
    magnitude: scalar_t,
    normalized: vector_t,
    dot(other: same vector_t): scalar_t,
}

vector3: complete itype vector_t = {
    shape: constant int[] = [3],
    length: constant int = 3,
    
    x: required scalar_t,
    y: required scalar_t,
    z: required scalar_t,
    
    operator new this(x: scalar_t, y: scalar_t, z: scalar_t) -> vector3 = {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    magnitude: dynamic scalar_t = get { return sqrt(x^2 + y^2 + z^2); }
    dot(other: vector3): scalar_t = { return x * other.x + y * other.y + z * other.z; }
    normalized: dynamic vector3 = get { return this / magnitude; }
    
    operator +(other: vector3): vector3 = { return vector3(x + other.x, y + other.y, z + other.z); }
    operator -(other: vector3): vector3 = { return vector3(x - other.x, y - other.y, z - other.z); }
    operator *(scalar: scalar_t): vector3 = { return vector3(x * scalar, y * scalar, z * scalar); }
    operator /(scalar: scalar_t): vector3 = { return vector3(x / scalar, y / scalar, z / scalar); }
 }
 
 vector4: complete itype vector_t alike vector3 {
    shape: constant int[] = [4],
    length: constant int = 4,
    
    x: required scalar_t,
    y: required scalar_t,
    z: required scalar_t,
    w: required scalar_t,
    
    operator new this(x: scalar_t, y: scalar_t, z: scalar_t, w: scalar_t) -> vector4 = {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    
    magnitude: dynamic scalar_t = get { return sqrt(x^2 + y^2 + z^2 + w^2); }
    dot(other: vector4): scalar_t = { return x * other.x + y * other.y + z * other.z + w * other.w; }
    normalized: dynamic vector4 = get { return this / magnitude; }
    
    operator +(other: vector4): vector4 = { return vector4(x + other.x, y + other.y, z + other.z, w + other.w); }
    operator -(other: vector4): vector4 = { return vector4(x - other.x, y - other.y, z - other.z, w - other.w); }
    operator *(scalar: scalar_t): vector4 = { return vector4(x * scalar, y * scalar, z * scalar, w * scalar); }
    operator /(scalar: scalar_t): vector4 = { return vector4(x / scalar, y / scalar, z / scalar, w / scalar); }
 }
 
 body_t: itype = {
    position: required vector3,
    velocity: required vector3,
    mass: required scalar_t,
    
    kinetic_energy(): scalar_t = { return 0.5 * mass * velocity.magnitude^2; }
    momentum(): vector3 = { return vector3(velocity.x * mass, velocity.y * mass, velocity.z * mass);
 }
 
 classical_body: complete itype body_t = {
    position: required vector3,
    velocity: required vector3,
    mass: required scalar_t,
    
    name: nullable string = null,
    color: nullable string = null,
    
    operator new this(position: vector3, velocity: vector3, mass: scalar_t) -> classical_body = {
        this.position = position;
        this.velocity = velocity;
        this.mass = mass;
    }
    
    kinetic_energy(): scalar_t = { return 0.5 * mass * velocity.magnitude^2; }
    momentum(): vector3 = { return vector3(velocity.x * mass, velocity.y * mass, velocity.z * mass);
 }
 
 state: complete itype = {
    bodies: required body_t[],
    time: required scalar_t,
    
    operator new this(bodies: body_t[], time: scalar_t) -> state = {
        this.bodies = bodies;
        this.time = time;
    }
    
    momentum() -> vector3 = { return bodies.foreach(b => b.momentum()).sum(); }
    kinetic_energy() -> scalar_t = { return bodies.foreach(b => b.kinetic_energy()).sum(); }
 }

physics_backend: itype = {
    acceleration(b: body_t, s: state) -> vector3,
}
 
 integration_backend: itype = {
    step(s: state, dt: scalar_t, pb: physics_backend) -> state,
 }
 
 classical_backend: complete itype physics_backend = {
    G: constant scalar_t = 6.67430e-11,
    softening: constant scalar_t = 1e-9,
    
    gravity(a: body_t, b: body_t) -> vector3 = {
        let delta = b.position - a.position;
        let mag = G * a.mass * b.mass / (delta.magnitude^2 + softening^2);
        return delta.normalized * (mag / delta.magnitude);
    }
    
    acceleration(b: body_t, s: state) -> vector3 = {
        let acc = vector3(0.0, 0.0, 0.0);
        for other in s.bodies.where(o => o != b) 
            acc += gravity(b, other);
        return acc;
    }
 }
 
 
 euler_backend: complete itype integration_backend = {
    step(s: state, dt: scalar_t, pb: physics_backend) -> state = {
        let new_bodies = s.bodies.map(b => {
            let acc = pb.acceleration(b, s);
            let new_velocity = b.velocity + acc * dt;
            let new_position = b.position + new_velocity * dt;
            return classical_body(new_position, new_velocity, b.mass);
        });
        return state(new_bodies, s.time + dt);
    }
 }